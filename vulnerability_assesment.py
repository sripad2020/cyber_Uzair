import asyncio
import os
import socket
import ssl
import json
import uuid
import time
from datetime import datetime
from typing import Dict, List, Optional
from concurrent.futures import ThreadPoolExecutor
import aiohttp
import nmap
from OpenSSL import crypto
from gvm.connections import UnixSocketConnection
from gvm.protocols.gmp import Gmp
from gvm.transforms import EtreeTransform


def make_json_serializable(obj):
    """Recursively convert non-JSON-serializable objects to serializable formats."""
    if isinstance(obj, bytes):
        return obj.decode('utf-8', errors='ignore')
    elif isinstance(obj, (list, tuple)):
        return [make_json_serializable(item) for item in obj]
    elif isinstance(obj, dict):
        return {
            make_json_serializable(k): make_json_serializable(v)
            for k, v in obj.items()
        }
    elif isinstance(obj, (set, frozenset)):
        return list(obj)
    return obj


async def perform_vulnerability_assessment(
        target: str,
        scan_id: str,
        openvas_socket: str = "/var/run/openvassd.sock",
        openvas_username: str = "admin",
        openvas_password: str = "admin",
        output_dir: str = "scan_results"
) -> Dict:
    """Perform an advanced vulnerability assessment using OpenVAS, port scanning, service detection, HTTP header analysis, and SSL/TLS analysis without requiring API keys."""

    # Initialize result dictionary
    result = {
        'target': target,
        'timestamp': datetime.utcnow().isoformat(),
        'target_ip': None,
        'open_ports': [],
        'services': {},
        'http_headers': {},
        'ssl_info': {},
        'nmap_vuln_info': [],
        'vulnerabilities': [],
        'openvas_scan': {}
    }
    executor = ThreadPoolExecutor(max_workers=10)
    os.makedirs(output_dir, exist_ok=True)

    # Resolve target to IP address
    try:
        target = target.replace('http://', '').replace('https://', '').split('/')[0]
        try:
            target_ip = await asyncio.get_event_loop().run_in_executor(
                executor, socket.gethostbyname, target
            )
            result['target_ip'] = target_ip
        except socket.gaierror:
            result = {'error': f'Could not resolve {target} to an IP address', 'error_type': 'ResolutionError'}
            with open(os.path.join(output_dir, f'{scan_id}.json'), 'w') as f:
                json.dump(result, f)
            return result
    except Exception as e:
        result = {'error': f'Invalid target: {str(e)}', 'error_type': 'ValidationError'}
        with open(os.path.join(output_dir, f'{scan_id}.json'), 'w') as f:
            json.dump(result, f)
        return result

    # Asynchronous port scanning and service detection
    async def scan_ports(ports: List[int] = None) -> None:
        if ports is None:
            ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 3389, 8080, 8443]

        async def check_port(ip: str, port: int) -> Optional[Dict]:
            try:
                conn = asyncio.open_connection(ip, port)
                reader, _ = await asyncio.wait_for(conn, timeout=2)
                reader.close()
                return {'port': port, 'state': 'open'}
            except:
                return None

        tasks = [check_port(target_ip, port) for port in ports]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        result['open_ports'] = [r['port'] for r in results if r and isinstance(r, dict)]

        # Service detection and vulnerability scanning using nmap NSE scripts
        try:
            nm = nmap.PortScanner()
            port_list = ','.join(map(str, result['open_ports']))
            nm.scan(target_ip, arguments=f'-sV --script=vulners,vuln -p{port_list}')
            for host in nm.all_hosts():
                for port in nm[host].all_tcp():
                    service = nm[host]['tcp'][port]
                    result['services'][port] = {
                        'name': service.get('name', 'unknown'),
                        'product': service.get('product', ''),
                        'version': service.get('version', ''),
                        'banner': service.get('extrainfo', '')
                    }
                    if 'script' in service:
                        for script_id, script_output in service['script'].items():
                            if script_id in ['vulners', 'vuln']:
                                result['nmap_vuln_info'].append({
                                    'port': port,
                                    'script': script_id,
                                    'output': script_output,
                                    'service': f"{service.get('product', '')} {service.get('version', '')}".strip()
                                })
                                if script_id == 'vulners':
                                    for line in script_output.splitlines():
                                        if 'CVE-' in line:
                                            parts = line.split()
                                            cve_id = next((p for p in parts if p.startswith('CVE-')), 'Unknown')
                                            score = next((p for p in parts if p.replace('.', '').isdigit()), '0.0')
                                            result['vulnerabilities'].append({
                                                'type': 'nmap_vuln',
                                                'details': f"{cve_id} found for {service.get('product', 'unknown')} on port {port}",
                                                'severity': 'high' if float(score) >= 7 else 'medium' if float(
                                                    score) >= 4 else 'low'
                                            })
        except Exception as e:
            result['services']['error'] = f"Nmap scan failed: {str(e)}"

    # Fetch and analyze HTTP headers
    async def fetch_http_headers(timeout: int = 5) -> None:
        async with aiohttp.ClientSession() as session:
            for scheme in ['http', 'https']:
                try:
                    async with session.get(f"{scheme}://{target}", timeout=timeout) as resp:
                        headers = dict(resp.headers)
                        result['http_headers'][scheme] = headers
                        security_headers = ['Content-Security-Policy', 'X-Frame-Options',
                                            'Strict-Transport-Security', 'X-Content-Type-Options']
                        missing_headers = [h for h in security_headers if h not in headers]
                        if missing_headers:
                            result['vulnerabilities'].append({
                                'type': 'missing_security_headers',
                                'details': f"Missing headers for {scheme}: {', '.join(missing_headers)}",
                                'severity': 'medium'
                            })
                except Exception as e:
                    result['http_headers'][scheme] = {'error': f"HTTP fetch failed: {str(e)}"}

    # Perform advanced SSL/TLS analysis
    async def analyze_ssl() -> None:
        try:
            ctx = ssl.create_default_context()
            with ctx.wrap_socket(socket.socket(), server_hostname=target) as s:
                s.settimeout(5)
                s.connect((target, 443))
                cert = s.getpeercert(True)
                cert_obj = crypto.load_certificate(crypto.FILETYPE_ASN1, cert)

                # Convert issuer and subject components to dict with string keys
                issuer_components = {
                    k.decode('utf-8', errors='ignore'): v.decode('utf-8', errors='ignore')
                    for k, v in cert_obj.get_issuer().get_components()
                }
                subject_components = {
                    k.decode('utf-8', errors='ignore'): v.decode('utf-8', errors='ignore')
                    for k, v in cert_obj.get_subject().get_components()
                }

                result['ssl_info'] = {
                    'issuer': issuer_components,
                    'subject': subject_components,
                    'valid_from': cert_obj.get_notBefore().decode('utf-8', errors='ignore'),
                    'valid_to': cert_obj.get_notAfter().decode('utf-8', errors='ignore'),
                    'serial': str(cert_obj.get_serial_number()),  # Convert to string
                    'signature_algorithm': cert_obj.get_signature_algorithm().decode('utf-8', errors='ignore'),
                    'cipher': s.cipher(),
                    'version': s.version()
                }

                if s.version() in ['TLSv1.0', 'TLSv1.1', 'SSLv3']:
                    result['vulnerabilities'].append({
                        'type': 'insecure_tls_version',
                        'details': f"Using outdated {s.version()}",
                        'severity': 'high'
                    })

                expiry = datetime.strptime(cert_obj.get_notAfter().decode('utf-8', errors='ignore'), '%Y%m%d%H%M%SZ')
                if expiry < datetime.utcnow():
                    result['vulnerabilities'].append({
                        'type': 'expired_certificate',
                        'details': f"Certificate expired on {expiry}",
                        'severity': 'high'
                    })
        except Exception as e:
            result['ssl_info'] = {'error': f"SSL analysis failed: {str(e)}"}

    # Run OpenVAS scan
    async def run_openvas_scan() -> None:
        try:
            connection = UnixSocketConnection(path=openvas_socket)
            transform = EtreeTransform()
            with Gmp(connection, transform=transform) as gmp:
                gmp.authenticate(openvas_username, openvas_password)
                target_id = gmp.create_target(
                    name=f"Target-{target_ip}-{uuid.uuid4()}",
                    hosts=[target_ip],
                    port_list_id='33d0cd82-57c6-11e1-8ed1-406186ea4fc5'
                ).get('id')
                task_id = gmp.create_task(
                    name=f"Scan-{target_ip}-{uuid.uuid4()}",
                    target_id=target_id,
                    scan_config_id='daba56c8-73ec-11df-a475-002264764cea',
                    scanner_id='08b69003-5f54-403b-8d0a-66b7e4d4b6c4'
                ).get('id')
                gmp.start_task(task_id)

                max_wait = 300
                start_time = time.time()
                while time.time() - start_time < max_wait:
                    task = gmp.get_task(task_id)
                    status = task.xpath('//status/text()')[0]
                    if status in ['Done', 'Stopped']:
                        break
                    await asyncio.sleep(10)

                report_id = task.xpath('//last_report/report/@id')[0] if task.xpath(
                    '//last_report/report/@id') else None
                if report_id:
                    report = gmp.get_report(report_id, filter='levels=hml')
                    results = report.xpath('//result')
                    vulnerabilities = []
                    for res in results:
                        vuln = {
                            'name': res.xpath('name/text()')[0] if res.xpath('name/text()') else 'Unknown',
                            'severity': res.xpath('severity/text()')[0] if res.xpath('severity/text') else 'Unknown',
                            'cve': res.xpath('nvt/cve/text()')[0] if res.xpath('nvt/cve/text') else 'None',
                            'description': res.xpath('description/text()')[0] if res.xpath(
                                'description/text') else 'No description'
                        }
                        vulnerabilities.append(vuln)
                        try:
                            severity = float(vuln['severity'])
                            result['vulnerabilities'].append({
                                'type': 'openvas',
                                'details': f"{vuln['name']} (CVE: {vuln['cve']})",
                                'severity': 'high' if severity >= 7 else 'medium' if severity >= 4 else 'low'
                            })
                        except ValueError:
                            result['vulnerabilities'].append({
                                'type': 'openvas',
                                'details': f"{vuln['name']} (CVE: {vuln['cve']})",
                                'severity': 'unknown'
                            })
                    result['openvas_scan'] = {
                        'target': target_ip,
                        'vulnerabilities': vulnerabilities,
                        'status': status
                    }
                else:
                    result['openvas_scan'] = {'error': 'No report generated'}

                gmp.delete_task(task_id)
                gmp.delete_target(target_id)
        except Exception as e:
            result['openvas_scan'] = {'error': f'OpenVAS scan failed: {str(e)}', 'error_type': 'OpenVASError'}

    # Run all scans concurrently
    try:
        tasks = [
            scan_ports(),
            fetch_http_headers(),
            analyze_ssl(),
            run_openvas_scan()
        ]
        await asyncio.gather(*tasks)
    except Exception as e:
        result['error'] = f"Scan execution failed: {str(e)}"
        result['error_type'] = 'ScanError'

    # Convert result to JSON-serializable format
    result = make_json_serializable(result)

    # Save results
    output_path = os.path.join(output_dir, f"{scan_id}.json")
    with open(output_path, 'w') as f:
        json.dump(result, f, indent=4)

    return result